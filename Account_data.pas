unit Account_data;

// Данные по аку
//   Все что может сделать бот на аке включено сюда
//   Начиная от входа в игру  и заканчивая выходом

interface
uses   Forms
      ,Controls
      ,Classes
      ,SHDocVw
      ,UContainer
      ,Trava_Class
      ,MSHTML
      ,SysUtils
      ,ComCtrls
      ,RzTreeVw
      ,x_bot_utl
      ,U_Utilites
      ,PerlRegEx
      ,ActiveX
      ,Dialogs
      ,Windows
      ,Variants
      ,UPrePare_Profile ;

type TAccount_Data = class

    procedure WebBrowserDocumentComplete(ASender: TObject;
      const pDisp: IDispatch; var URL: OleVariant);
  private
    fWBContainer: TWBContainer;
    fMyAccount: TAccount;
    fWebBrowser: TWebBrowser;
    fAccountNode: TTreeNode;
    fAccounts_TreeView: TRzTreeView;
    FLog: TStringList;
  public
    constructor Create(AOwner:TComponent);
    //Логин для Т4 и Т3.6 версии одинаков
    function is_login_page(document: IHTMLDocument2): IHTMLFormElement;   // Проверка страницы на страницу входа
    function Account_login(LoginForm: IHTMLFormElement): boolean;         //  Логие
    function Bot_Start_Work(aAccounts_TreeView:TRzTreeView; aAccountNode:TTreeNode; ALog: TStringList): boolean;  // Запуск бота для работі с аком Т3,6
    //Для работы с профилем все переехало в unit UPrePare_Profile;
    function get_race_from_KarteT36(document: IHTMLDocument2): integer;      // Получение расы по карте

    function FindAndClickHref(document: IHTMLDocument2; SubHref:string;TypeSubHref:integer): IHTMLDocument2;   // Эмуляция работы пользователя - Найти ссылку и кликнуть по нец

    procedure set_AccountNode_StateIndex;
    property Log: TStringList read FLog write FLog;
    property WebBrowser: TWebBrowser read fWebBrowser write fWebBrowser;
    property WBContainer: TWBContainer read fWBContainer write fWBContainer;
    property MyAccount: TAccount read fMyAccount write fMyAccount;
    property AccountNode:TTreeNode read fAccountNode write fAccountNode;
    property Accounts_TreeView:TRzTreeView read fAccounts_TreeView write fAccounts_TreeView;
end;

type
  PNodeData = ^TNodeData;
  TNodeData = record
    NodeType: integer;  // -1  - сервер
                        // -2  - Account
                        // -3  - Village
    Status: Boolean;    // только для Account
                        //  True  - Login
                        //  False - Logout
    ID:    string;      // UID - для Account
                        // ID - для Village
    Account_Data:TAccount_Data;
    FData: string;      // - Сервер  (NodeType=-1)
                        // - Пароль  (NodeType=-2)
  end;

function find_node(Tree: TRzTreeView; Node: TTreeNode; NodeName: String;NodeType: integer): TTreeNode; // Поиск узла

implementation

function find_node(Tree: TRzTreeView; Node: TTreeNode;
  NodeName: String; NodeType: integer): TTreeNode;
  // Поиск узла
  //    Если узел не найден то возвращается  nil
  //    иначе найденный узел
  //  Tree       -   Дерево  сервера-акки-деревни
  //  Node       -   Узел (ветка) в котором надо найти требуемы "под-узел" если он не указан то поиск идет начиная с корня дерева
  //  NodeName   -   Имя узла который надо найти
  //  NodeType   -   Тип узла который надо найти
  //
var
  t: integer;
begin
  Result:=nil;

  IF not Assigned(Node) then
  Begin  // Поиск идёт в корне
    Node:=Tree.Items.GetFirstNode;
    While Assigned(Node) Do
    Begin
      IF (Node.Text = NodeName) and (PNodeData(Node.Data)^.NodeType = NodeType) then
      Begin
        Result:=Node;
        Break;
      End;
      Node:=Node.GetNextSibling;
    End;
  End  // Поиск идёт в корне
  Else begin  // Поиск идёт в ветке
    For t:=0 to Node.Count - 1 Do
    Begin
      IF (Node[t].Text = NodeName) and (PNodeData(Node[t].Data)^.NodeType = NodeType) then
       Begin
         Result:=Node[t];
         Break;
       End;
     End; // Поиск в ветке
  end;
end;



{ TAccount_Data }

function TAccount_Data.Account_login(LoginForm: IHTMLFormElement): boolean;
//  Логин
//     Возвращает  TRUE  -  при успешном логине
//                 FALSE -  при неудачном
// LoginForm   -  Страница логина
//
var
  ItemNumber: integer;
  field: IHTMLElement;
  input_field: IHTMLInputElement;
  Count_input_field: integer;
begin
// Логика работы
//  Пробежаться по всем полям формы
//  найти нужные нам поля ('name' и 'password')
//   заполнить их и нажать на кнопочку Вход
  FLog.Add('Логинимся ...');
  Result:=false;
  Count_input_field:=0;
  if Assigned(LoginForm) then
  begin
    for ItemNumber := 0 to LoginForm.Length - 1 do
    begin  //  бежим по всем элементам формы
      field := LoginForm.Item(ItemNumber,'') as IHTMLElement;
      if Assigned(field) then
      begin
        if field.tagName = 'INPUT' then
        begin  //  поле ввода
          input_field:=field as IHTMLInputElement;
          if input_field.Name = 'name' then
          begin
            input_field.Value := MyAccount.Login;    // Внесем сюда имя
            Count_input_field:=Count_input_field+1;
          end; //  'name'
          if input_field.Name = 'password' then
          begin
            input_field.Value := MyAccount.Password; // Внесем сюда пароль
            Count_input_field:=Count_input_field+1;
          end;  // 'password'
        end;
      end; //  поле ввода
    end;   //  бежим по всем элементам формы

    if Count_input_field <> 2 then
      begin
        FLog.Add('Нашли больше 2 полей ввода , дето накасячили');
        exit;  //  Если в форме не ДВА поля ввода  то мы где-то что-то прогавили
      end;
    FLog.Add('Нажали на кнопку ...');
    fWBContainer.MyFormSubmit(LoginForm); //   Нажали на кнопочку

    //  Проверим залогинились или нет
    //     собственно проверка тупая
    //  если на полученной страницы нет формы логина то всё в порядке
    Result:=(is_login_page(fWBContainer.HostedBrowser.Document as IHTMLDocument2) = nil);
    if Result then
      FLog.Add('Залогинились!')
    else
      FLog.Add('Логин не удался КОСЯК!!!');
  end;

end;

function TAccount_Data.Bot_Start_Work(aAccounts_TreeView:TRzTreeView; aAccountNode:TTreeNode; ALog: TStringList): boolean;
//      Запуск работы бота с заданным аком
//  aAccounts_TreeView   - Дерево сервера-аки-деревни
//  aAccountNode         - Узел ака в дереве
//
//  Собственно говоря логин и парсинг текущего состояния ака
//
var
  Server_Name  : string;
  User_Name    : string;
  Password_Name: string;
  ServerNode: TTreeNode;
  VillNode: TTreeNode;
  SndForm: IHTMLFormElement;
  Document: IHTMLDocument2;
  DocumentHTML: IHTMLDocument2; //нужно для норм отображения title (На Win XP)
  Tmp_VillName:String;
  NodeDataPtr: PNodeData;
  t: integer;
  url: string;
  i: integer;
  next_dorf: string;
  HTML: String; //сохраняем сюда исходный код страницы
  V_HTML: OleVariant; //нуна для запихания  HTML в DocumentHTML
begin
  //  Проверять не будем ибо все-же надо перед вызовом процедуры проверить
  //  1. Assigned(aAccounts_TreeView)
  //        т.е. существует дерево аков
  //  2. (PNodeData(aAccountNode.Data)^.NodeType = -2) and (not PNodeData(aAccountNode.Data)^.Status)
  //        т.е. Это Account и он не залогинен
  //  -----------------------------------------------
  //THTML := TStrings.Create;
  FLog := ALog;
  Result:=False;

  Server_Name:='';
  User_Name:='';
  Password_Name:='';

  fAccounts_TreeView:=aAccounts_TreeView;
  fAccountNode:=aAccountNode;
  User_Name:=AccountNode.Text;
  Password_Name:=PNodeData(AccountNode.Data)^.FData;
      // И теперь сервер
  ServerNode:=AccountNode.Parent;   // Узел сервера
      // Проверим все-же!!!
  if (PNodeData(ServerNode.Data)^.NodeType = -1) then
  begin
    Server_Name:=ServerNode.Text;
  end;

  if (Server_Name <> '') and (User_Name <> '') and (Password_Name <> '') then
  begin
    MyAccount.Connection_String:='http://'+Server_Name;
    MyAccount.Login:=User_Name;
    MyAccount.Password:=Password_Name;
    FLog.Add('Пользователь - ' + User_Name);
    FLog.Add('Переход по ссылке' + MyAccount.Connection_String);
    WBContainer.MyNavigate(MyAccount.Connection_String);   //   Получение страницы логины
    //когда получили страницу логина можно определить версию игры
    if WB_GetHTMLCode(WBContainer, HTML) then
       if AnsiPos('Travian.Game.version = ''4.0''',HTML) <> 0 then
         begin
           MyAccount.IsT4Version := True;
           FLog.Add('Версия игры Т4.0')
         end
       else
         begin
           MyAccount.IsT4Version := False; //или не Т4 или дето накасячил
           FLog.Add('Версия игры НЕ Т4.0');
         end;
    SndForm:=is_login_page(WBContainer.HostedBrowser.Document as IHTMLDocument2);  //  вытащим из неё форму логина
    if Assigned(SndForm) then
    begin  //  форма логина существует
      Result:=Account_login(SndForm);   //  Попытка логина
      if Result then
      begin  // Логин нормальный!
        // Перейдем на страницу профиля!
        FLog.Add('Переходим на страницу профиля');
        Document:=FindAndClickHref(WBContainer.HostedBrowser.Document as IHTMLDocument2,MyAccount.Connection_String+'/spieler.php?',2);
        if Document <> nil then
        begin //  Успешный переход на страницу профиля
          FLog.Add('Успешный переход на страницу профиля.');
          //Данное извращение надо для получениу екземпляра IHTMLDocument2
          //потом в него пихаем исходный код страницы и при дальнейшей работе
          //у нас вполне нормально title получаеться
          if MyAccount.IsT4Version then //если Т 4.0 версия то надо
          //дополнительно создать екземпляр документа и тд ... выше описано
          begin
            WB_GetHTMLCode(WBContainer,HTML);
            V_HTML := VarArrayCreate([0, 0], varVariant);
            V_HTML[0] := HTML;
            DocumentHTML := coHTMLDocument.Create as IHTMLDocument2;;
            DocumentHTML.Write(PSafeArray(TVarData(V_HTML).VArray));
            prepare_profileT4(Document, DocumentHTML, MyAccount, Flog);  // обработка профиля
          end
          else
            begin
              prepare_profileT36(Document, MyAccount, FLog);  // обработка профиля
              if MyAccount.Race = 0 then  MyAccount.Race:=get_race_from_KarteT36(Document);  // Расу в профиле определить не смогли! Будем её определять как-то иначе!
            end;
        end;
      end;  // Логин нормальный!
    end;   // Assigned(SndForm)

    PNodeData(AccountNode.Data)^.Status:=Result;
    if Result then
    begin  // Логин нормальный!
      set_AccountNode_StateIndex;  //  установит индекс картинки для ака будем рисовать в дереве
      PNodeData(AccountNode.Data)^.ID:=MyAccount.UID;
      PNodeData(AccountNode.Data)^.Account_Data:=self;   // !!!!! Внесем себя !!!!!

      // Добавим  в дерево список деревень
      for t := 0 to MyAccount.Derevni_Count-1 do
      begin  //   Пробежимся по всем деревням
        //  Вообщето может быть не самая удачная идея использовать в качестве идентификатора
        //  наименование деревни ибо после переименования ейной возможны проблемы
        //  однако на этапе логина всё нормально ибо тут переименованием и не пахнет
        Tmp_VillName:=MyAccount.Derevni.Items[t].Name+' '+MyAccount.Derevni.Items[t].coord;
        VillNode:=find_node(Accounts_TreeView,AccountNode,Tmp_VillName,-3);
        if not Assigned(VillNode) then
        begin // Деревню не нашли --> добавим её
              // добавляем дочерний по отношению к AccountNode узел,
              // в качестве текста исп. Tmp_VillName
          New(NodeDataPtr);
          NodeDataPtr^.NodeType:=-3;
          NodeDataPtr^.Status:=False;
          NodeDataPtr^.ID:=IntToStr(MyAccount.Derevni.Items[t].ID);
          NodeDataPtr^.FData:=MyAccount.Derevni.Items[t].Name;
          NodeDataPtr^.Account_Data:=self;   // !!!!! Внесем себя !!!!!
          VillNode:=Accounts_TreeView.Items.AddChildObject(AccountNode, Tmp_VillName, NodeDataPtr);
        end;
      end;  // for t := 0 to MyAccount.Derevni_Count-1

      // Все с визуализацией временно покончили
      // Теперь надо пройтись по всем деревням и зачитать их данные
      // И будем это делать в отдельном цикле, хотя могли бы и в предыдущем
      // однако негоже смешивать две разные вещи!!!!
      for t := 0 to MyAccount.Derevni_Count-1 do
      begin // цикл по деревням
        // Переключимся на нужную деревню
        // Ну а если деревушка одна то то мы всё равно стоим на ней!!!
        if MyAccount.Derevni_Count > 1 then
          document:=FindAndClickHref(document,'?newdid='+MyAccount.Derevni.Items[t].NewDID + '&uid=' + MyAccount.UID,4);
        if Assigned(document) then
        begin  // Успешное переключение!
           MyAccount.IdCurrentVill:=MyAccount.Derevni.Items[t].ID;
          // Посмотрим где мы стоим
          // Если не на dorf1 или 2 то переключаемся на dorf1
          url:=document.url;
          if (copy(url,length(url)-4) <> 'dorf1') and (copy(url,length(url)-4) <> 'dorf2') then // Переключимся на dorf1
            document:=FindAndClickHref(document,MyAccount.Connection_String+'/dorf1.php',1);

          for I := 1 to 2 do
          begin
            url:=document.url;
            if (copy(url,length(url)-8) = 'dorf1.php') then
            begin
              // Для Т4 Версии другая логика получения данных ферм .
              if MyAccount.IsT4Version then
                 MyAccount.Derevni.Items[t].prepare_dorf1T4(document)
              else
                MyAccount.Derevni.Items[t].prepare_dorf1(document);  // Обработка  dorf1
              next_dorf:='dorf2.php'
            end
            else begin
              if (copy(url,length(url)-8) = 'dorf2.php') then
              begin
                MyAccount.Derevni.Items[t].prepare_dorf2(document);  // Обработка  dorf2
                MyAccount.Derevni.Items[t].SetGidForId40(30+MyAccount.race);  // Это ограда!!!!
                next_dorf:='dorf1.php'
              end
              else begin
                // логическая ошибка
              end;
            end;
            document:=FindAndClickHref(document,MyAccount.Connection_String+'/'+next_dorf,1);
          end; // for I
        end;  // if Assigned(document)
      end;   // цикл по деревням
    end;    // if Result then  Логин нормальный!

  end;  // (Server_Name <> '') and (User_Name <> '') and (Password_Name <> '')
end;

constructor TAccount_Data.Create(AOwner:TComponent);
begin
//  inherited Create(AOwner) ;



  fMyAccount:=TAccount.Create;

  fWebBrowser:=TWebBrowser.Create(AOwner);
  TWinControl(fWebBrowser).Parent:=(AOwner as TWinControl);
  fWebBrowser.Align:=alClient;
  fWebBrowser.OnDocumentComplete:=WebBrowserDocumentComplete;

  // Создание контейнера
  fWBContainer := TWBContainer.Create(fWebBrowser);
//  fWBContainer.OptionKeyPath:= 'Software\X-bot\Explorer';  // Настройки хранятся в HKEY_CURRENT_USER
//  fWBContainer.UseCustomCtxMenu := True;    // use our popup menu
//  fWBContainer.Show3DBorder := False;       // no border
//  fWBContainer.ShowScrollBars := False;     // no scroll bars
//  fWBContainer.AllowTextSelection := False; // no text selection (**)

end;

function TAccount_Data.FindAndClickHref(document: IHTMLDocument2;
  SubHref: string; TypeSubHref: integer): IHTMLDocument2;
//   Найти ссилку и кликнуть по ней

// TypeSubHref   - Модификатор поиска
//     1 - найти полное равенство ссылки с SubHref
//     2 - ссылка должна начинаться с SubHref
//     3 - ссылка должна содержать SubHref
//     4 - ссылка должна заканчиваться SubHref
var
  ItemNumber: integer;
  href_field: IHTMLElement;
  All_Links: IHTMLElementCollection;
  url:string;
  Is_Find: boolean;
begin
  Result:=nil;
  if Assigned(document) then
  begin
    All_Links:=document.links;
    for ItemNumber := 0 to All_Links.Length - 1 do
    begin  // цикл по всем ссылкам документа
      href_field := All_Links.item(ItemNumber,'') as IHTMLElement;
      url:=href_field.toString;
      Is_Find:=(TypeSubHref = 1) and (url = SubHref);
      if not Is_Find then
        Is_Find:=(TypeSubHref = 2) and (pos(SubHref,url) = 1);
      if not Is_Find then
        Is_Find:=(TypeSubHref = 3) and (pos(SubHref,url) > 0);
      if not Is_Find then
        Is_Find:=(TypeSubHref = 4) and (pos(SubHref,url) = length(url)-length(SubHref)+1);
      if Is_Find then
      begin // Отлично нашли требуемую ссылку
        WBContainer.MyElementClick(href_field);
        Result:=WBContainer.HostedBrowser.Document as IHTMLDocument2;
        exit;
      end;
    end;  // цикл по всем ссылкам документа
  end;
end;

function TAccount_Data.get_race_from_KarteT36(document: IHTMLDocument2): integer;
// Определение расы по карте

var
  ItemNumber: integer;
  href_field: IHTMLElement;
  All_Links: IHTMLElementCollection;
  url:string;
  Karte_document: IHTMLDocument2;
  field_Element: IHTMLElement;

  Tmp_Collection:IHTMLElementCollection;
  Script_Number: integer;
  tmp_txt: string;
  Race_String: string;
  iii: integer;
begin
  Result:=0;
  // Сначала найдем ссылку на карту и кликнем по ней
  // дабы перейти на страницу карты
  if Assigned(document) then
  begin
{   У нас же есть соответствующая функция и значит надо использовать её
    просто закоментарил ибо не проверял, после проверки надо удалить
    закоментаренній код
    All_Links:=document.links;
    for ItemNumber := 0 to All_Links.Length - 1 do
    begin
      href_field := All_Links.item(ItemNumber,'') as IHTMLElement;
      url:=href_field.toString;
      if url = (MyAccount.Connection_String+'/karte.php') then
      begin // Отлично нашли ссылку на карту
        WBContainer.MyElementClick(href_field);
        Karte_document:=WBContainer.HostedBrowser.Document as IHTMLDocument2;
        break;
      end;
    end;
}
    Karte_document:=FindAndClickHref(document,MyAccount.Connection_String+'/karte.php', 1);
  end;

  if Assigned(Karte_document) then
  begin  // Итак карту мы получили, теперь попробуем с ней разобраться
    field_Element:=(document as IHTMLDocument3).getElementById('a_3_3');  // Центр карты
    url:=field_Element.toString;   // ссылка на деревушку
    url:=copy(url,pos('?',url)+1);     // нужный нам кусочек

    field_Element:=(document as IHTMLDocument3).getElementById('map');  // Отсюда нам нужен второй скрипт
    Script_Number:=0;
    Tmp_Collection:=(field_Element.children as ihtmlelementcollection);
    for ItemNumber := 0 to Tmp_Collection.Length - 1 do
    begin
      field_Element:=Tmp_Collection.item(ItemNumber,'')  as IHTMLElement;
      if field_Element.tagName = 'SCRIPT' then
      begin
        Script_Number:=Script_Number+1;
        if Script_Number >= 2 then break;
      end;
    end;
    if Script_Number = 2 then
    begin  // Нужный нам скрипт Из него вытащим расу
           // По простому по рабочекрестьянски
           // Нам нужен центр карты и мы его получим!  Петр упорный :) яб регулярку юзнул...
      tmp_txt:=field_Element.innerHTML;
      tmp_txt:=copy(tmp_txt,pos(']]',tmp_txt)+3);   // Выбросили первую строку карты
      tmp_txt:=copy(tmp_txt,pos(']]',tmp_txt)+3);   // Выбросили вторую строку карты
      tmp_txt:=copy(tmp_txt,pos(']]',tmp_txt)+3);   // Выбросили третюю строку карты
      tmp_txt:=copy(tmp_txt,1,pos(']]',tmp_txt)+1);   // Взяли 4-ю строку
           // Работаем с 4-й строкой
      tmp_txt:=copy(tmp_txt,pos(']',tmp_txt)+2);   // Выбросили первую колонку карты
      tmp_txt:=copy(tmp_txt,pos(']',tmp_txt)+2);   // Выбросили вторую колонку карты
      tmp_txt:=copy(tmp_txt,pos(']',tmp_txt)+2);   // Выбросили третюю колонку карты
      tmp_txt:=copy(tmp_txt,1,pos(']',tmp_txt));   // Взяли 4-ю колонку
           // И теперь имеем то что нам нужно
           // [X,Y,?,?,"URL","?","Наименование_Деревни","Игрок","Население","?",Раса]
           //  Раса = 1 - рим  2 - тевтон   3 - галл
      Race_String:=copy(tmp_txt,length(tmp_txt)-1,1);
      Result:=StrToInt(Race_String);
    end;
  end;  // if Assigned(Karte_document)
end;

function TAccount_Data.is_login_page(document: IHTMLDocument2): IHTMLFormElement;
//  Если на входе страница логина, то вытаскиваем из неё форму и возвращаем
//   иначе NIL
var
  allForms: IHTMLElementCollection;
begin
  //  Страница логина?????
  Result:=nil;
  if  Assigned(document) then
  begin
    allForms:=document.forms;
    if Assigned(allForms) then
      Result:=allForms.Item('snd','') as IHTMLFormElement;
      if Assigned(Result) then
        if Result.action <> 'dorf1.php' then Result:=nil;
  end;
end;


procedure TAccount_Data.set_AccountNode_StateIndex;
begin
  AccountNode.StateIndex:=MyAccount.Race;
end;




procedure TAccount_Data.WebBrowserDocumentComplete(ASender: TObject;
  const pDisp: IDispatch; var URL: OleVariant);
begin
  fWBContainer.DocLoaded := true;
end;

end.
